1. BFS
   1 부터 시작해서 3곱하기, 2곱하기, 1더하기의 연산을 시도하며 N을 만들때 까지 반복한다. 연산 결과가 N보다 큰 경우나 최대값 1,000,000을 넘어서면 그 다음은 시도하지 않는다. 최소 연산 횟수를 구해야하고, BFS의 경우 최단거리를 보장하기 때문에 가장 처음 N 값을 만족시키는 depth가 정답이다. 즉 동일한 depth에서의 세 가지 연산을 시도해보며 탐색해 나가는 방법이다.

2. DP
   1부터 시작하여 3곱하기, 2곱하기, 1더하기를 모두 수행하며 점화식을 사용해 N값을 만든 경우 1을, N값을 넘어간 경우 -1을 반환한다. 세 가지 결과가 -1이 아닌 경우를 제외하고 최소값을 현재 수의 결과로 저장하고(메모이제이션) 이전으로 결과를 반환해줄 때는 1을 현재 결과에 더해서 반환한다. 탐색 시 메모이제이션에 값이 있는 숫자인 경우에도 역시 저장된 해당 값에 1을 더해서 반환한다.  
아래 그림은 N=5 인 경우이다. 

   ![1463 1로 만들기_img1](https://user-images.githubusercontent.com/19742979/81505237-c6b5ce80-9328-11ea-946f-5a429a91de77.png)


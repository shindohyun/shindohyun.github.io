- 중복 검사 시 맵의 위치 뿐만아니라 점수도 고려해야한다.

- 처음에는 시작 노드와 도착 노드 그리고 분기점 (10, 20, 25, 30, 40)을 기준으로 경로를 나누고 각 경로를 행으로 하는 이차원 배열을 맵 생성했다.  

  ```6, 18java
  int[][] map = {
    {-1},
    {2, 4, 6, 8, 10},
    {12, 14, 16, 18, 20},
    ...
  }
  ```

  이렇게 맵을 생성하면 각 경로(행) 마다 노드의 개수가 다르다. 탐색 시 각 행의 길이를 매번 구해야하는 비효율적인면이 있다.

- 윷놀이 판을 어떻게 구현하고 탐색하는가에 따라서 시간을 단축시킬 수 있다.  
  노드의 인덱스를 저장하여 이동 순서 정보를 담는 이차원 배열(빨간 경로, 파란 경로)과 각 노드의 점수를 저장하는 배열, 이 두 개의 맵으로 윷놀이 판을 표현하게 되면 **단일 반복문으로 한 번에 탐색이 가능**하다.  

  ```java
  final int NODE_CNT = 33; //시작, 도착을 포함한 노드의 개수는 총 33개
  final int RED = 0;
  final int BLUE = 1;
  final int END_IDX = 22; //도착지점 index 는 22 (빨간색 경로 시계방향으로 이동했을 때)
  
  int[][] path = new int[NODE_CNT][2];
  path[0][RED] = 1; //index 0->1 (index 0은 시작 노드)
  path[1][RED] = 2; //index 1->2
  //...
  //파란색 노드의 경우 빨간색, 파란색 경로를 모두 저장한다.
  path[5][RED] = 6; //index 5->6
  path[5][BLUE] = 22; //index 5->22 (index 22는 파란색 경로의 노드)
  //...
  path[END_IDX][RED] = END_IDX; //*도착한 말은 이동할 곳이 없기 때문에 제자리
  
  int[] score = new int[NODE_CNT];
  score[1] = 2;
  score[2] = 4;
  //...
  ```

- **10회의 각 턴 마다 4개의 말 중 하나를 선택해야한다. 각 턴에서 어떤 말을 사용하는가에 따라서 점수가 달라진다. 즉, *순서를 고려하여 4개의 말을 고르는* 모든 경우의 수를 구해야한다.** 따라서 *순열과 같다.* 하지만 한 번 사용한 말을 다시 사용할 수 있다는 점이 다르다. 때문에 순열 알고리즘에서 말에 대한 방문 체크하는 것을 빼면 된다.  
  예를 들어 10회 진행할 때 선택되는 말의 순서는 다음과 같을 수 있다.  
  {1, 1, 1, ... , 1}, {1, 1, 1, ... , 2}, ... , {1, 2, 1, 1, ... , 1}, ...


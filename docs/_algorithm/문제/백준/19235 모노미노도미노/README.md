- 파란색 보드와 초록색 보드 모두 6x4 맵으로 표현하는것이 편하다. 블록을 오른쪽으로 이동시키면서 갱신시킬때 행을 변경하면 되기 때문에 편리하다. (`map[0] = newRow` 이런 식으로...) 반면 4x6 맵으로 표현하게되면 블록은 아래로 이동시키면서 갱신할때 열 자체를 변경하는 것이 번거롭다.  
  초록색 맵에 넣는 경우 애초에 입력되는 t, x, y 를 수정해서 넣어주면 된다. 그렇게되면 블록을 이동하고, 삭제하는 함수들을 공통으로 사용할 수 있다.
- 문제에서 주의해야할 점 : 0, 1 열은 항상 비어있다(블록 추가 시 0~1열에 넣어주고 루틴을 시작하면 된다.), 블록은 합쳐지지 않는다, 나누어지는 경우는 행이나 열로 가득찬 경우이다.
- 블록을 이동시키는 과정에서 어려웠다. 처음에는 블록 사이즈에 맞게 빈 곳을 찾았지만, 간단히 생각하는것이 도움이 되었다. 현재 블록에서 오른쪽으로 나아가면서 처음 만나는 다른 블록에서 탐색을 멈추고 해당 블록 앞의 열을 기준으로 각 블록 타입에 맞게 블록을 놓을 수 있는지 판단했다.
- 블록 종류 별로 검사해야할 범위 예를들어 2번 타입인 경우 앞|뒤 열, 3번 타입인 경우 위|아래 행의 인덱스 범위가 정해진 사이즈를 넘어가지 않게 예외처리에 신경써야했다.
- 크게 네 가지 구현으로 나눌 수 있다. 1. 블록 추가, 2. 오른쪽으로 밀기, 3. 가득 차있는 열 제거, 4. 0, 1 번 열 제거

---

- 과정  
  1. 블록 추가
  2. 아래로 내리기
  3. 제거되는 행 없을때 까지 반복
     1. 2~5행 사이에 일렬 배치되는 행 있으면 제거하고 점수+1
     2. 아래로 내리기
  4. 0~1행에 블록 있으면 해당되는 행 개수 만큼 아래 행 제거
- 모든 블록을 아래로 내리는 함수 만들기  
  가장 아래에 있는 행 부터 탐색 `for(int r = 5; r >= 0; r--){ for(int c = 0; c < 4; c++) {...}}`

